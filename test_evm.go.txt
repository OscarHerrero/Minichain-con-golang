package main

import (
	"fmt"
	"minichain/evm"
)

func main() {
	fmt.Println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Println("â•‘                                          â•‘")
	fmt.Println("â•‘              TEST EVM v1.0               â•‘")
	fmt.Println("â•‘                                          â•‘")
	fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	// MenÃº de pruebas
	fmt.Println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Println("â•‘         PROGRAMAS DE PRUEBA            â•‘")
	fmt.Println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
	fmt.Println("â•‘ 1. Suma simple: 5 + 3                  â•‘")
	fmt.Println("â•‘ 2. MultiplicaciÃ³n: 7 * 4               â•‘")
	fmt.Println("â•‘ 3. Operaciones complejas               â•‘")
	fmt.Println("â•‘ 4. Guardar en storage                  â•‘")
	fmt.Println("â•‘ 5. Leer de storage                     â•‘")
	fmt.Println("â•‘ 6. Comparaciones                       â•‘")
	fmt.Println("â•‘ 7. Stack avanzado (DUP, SWAP)          â•‘")
	fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	fmt.Print("\nðŸ‘‰ Selecciona un programa (1-7): ")
	var choice int
	fmt.Scan(&choice)
	
	var bytecode []byte
	var description string
	
	switch choice {
	case 1:
		// Programa 1: 5 + 3
		description = "Suma: 5 + 3"
		bytecode = []byte{
			0x60, 0x05, // PUSH1 5
			0x60, 0x03, // PUSH1 3
			0x01,       // ADD
			0x00,       // STOP
		}
		
	case 2:
		// Programa 2: 7 * 4
		description = "MultiplicaciÃ³n: 7 * 4"
		bytecode = []byte{
			0x60, 0x07, // PUSH1 7
			0x60, 0x04, // PUSH1 4
			0x02,       // MUL
			0x00,       // STOP
		}
		
	case 3:
		// Programa 3: (10 + 5) * 2 - 3
		description = "Operaciones complejas: (10 + 5) * 2 - 3"
		bytecode = []byte{
			0x60, 0x0a, // PUSH1 10
			0x60, 0x05, // PUSH1 5
			0x01,       // ADD â†’ 15
			0x60, 0x02, // PUSH1 2
			0x02,       // MUL â†’ 30
			0x60, 0x03, // PUSH1 3
			0x03,       // SUB â†’ 27
			0x00,       // STOP
		}
		
	case 4:
		// Programa 4: Guardar en storage
		description = "Guardar 100 en storage[0] y 200 en storage[1]"
		bytecode = []byte{
			0x60, 0x64, // PUSH1 100 (valor)
			0x60, 0x00, // PUSH1 0 (key)
			0x55,       // SSTORE â†’ storage[0] = 100
			
			0x60, 0xc8, // PUSH1 200 (valor)
			0x60, 0x01, // PUSH1 1 (key)
			0x55,       // SSTORE â†’ storage[1] = 200
			
			0x00,       // STOP
		}
		
	case 5:
		// Programa 5: Guardar y leer de storage
		description = "Guardar 42 en storage[5] y luego leerlo"
		bytecode = []byte{
			// Guardar
			0x60, 0x2a, // PUSH1 42 (valor)
			0x60, 0x05, // PUSH1 5 (key)
			0x55,       // SSTORE â†’ storage[5] = 42
			
			// Leer
			0x60, 0x05, // PUSH1 5 (key)
			0x54,       // SLOAD â†’ carga storage[5]
			
			// Duplicar el valor leÃ­do
			0x80,       // DUP1
			
			0x00,       // STOP
		}
		
	case 6:
		// Programa 6: Comparaciones
		description = "Comparaciones: 10 > 5, 3 < 8, 7 == 7"
		bytecode = []byte{
			// 10 > 5
			0x60, 0x0a, // PUSH1 10
			0x60, 0x05, // PUSH1 5
			0x11,       // GT â†’ 1 (true)
			
			// 3 < 8
			0x60, 0x03, // PUSH1 3
			0x60, 0x08, // PUSH1 8
			0x10,       // LT â†’ 1 (true)
			
			// 7 == 7
			0x60, 0x07, // PUSH1 7
			0x60, 0x07, // PUSH1 7
			0x14,       // EQ â†’ 1 (true)
			
			0x00,       // STOP
		}
		
	case 7:
		// Programa 7: DUP y SWAP
		description = "Stack avanzado: DUP y SWAP"
		bytecode = []byte{
			0x60, 0x0a, // PUSH1 10
			0x60, 0x14, // PUSH1 20
			0x60, 0x1e, // PUSH1 30
			// Stack: [10, 20, 30]
			
			0x80,       // DUP1 â†’ duplica el tope
			// Stack: [10, 20, 30, 30]
			
			0x90,       // SWAP1 â†’ intercambia tope y segundo
			// Stack: [10, 20, 30, 30] â†’ [10, 20, 30, 30]
			
			0x00,       // STOP
		}
		
	default:
		fmt.Println("âŒ OpciÃ³n invÃ¡lida")
		return
	}
	
	// Ejecutar el bytecode
	fmt.Printf("\nðŸ“‹ Programa: %s\n", description)
	fmt.Printf("ðŸ“¦ Bytecode: %x\n", bytecode)
	
	// Crear VM con suficiente gas
	vm := evm.NewVM(bytecode, 100000)
	
	// Ejecutar
	if err := vm.Run(); err != nil {
		fmt.Printf("\nâŒ Error: %v\n", err)
		return
	}
	
	// Mostrar estado final
	fmt.Println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Println("â•‘          ESTADO FINAL                  â•‘")
	fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	vm.PrintState()
}