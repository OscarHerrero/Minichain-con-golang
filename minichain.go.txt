/*
package main

import (
	"bufio"
	"fmt"
	"minichain/blockchain"
	"minichain/crypto"
	"os"
	"strconv"
	"strings"
)
func main() {
	fmt.Println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Println("â•‘                                          â•‘")
	fmt.Println("â•‘          ğŸ”— MINICHAIN v2.0 ğŸ”—           â•‘")
	fmt.Println("â•‘   Blockchain con Transacciones          â•‘")
	fmt.Println("â•‘                                          â•‘")
	fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

	// Crear la blockchain con dificultad 3
	fmt.Println("\nğŸš€ Creando blockchain...")
	bc := blockchain.NewBlockchain(3)

	// Crear una wallet para gestionar cuentas
	wallet := crypto.NewWallet()

	// Crear 3 cuentas de ejemplo y darles saldo inicial
	fmt.Println("\nğŸ’¼ Creando cuentas de ejemplo...")

	account1, _ := wallet.CreateAccount()
	bc.AccountState.AddBalance(account1, 100.0)

	account2, _ := wallet.CreateAccount()
	bc.AccountState.AddBalance(account2, 50.0)

	account3, _ := wallet.CreateAccount()
	bc.AccountState.AddBalance(account3, 75.0)

	fmt.Println("\nğŸ’° Saldos iniciales asignados:")
	fmt.Printf("   Cuenta 1: 100 MTC\n")
	fmt.Printf("   Cuenta 2: 50 MTC\n")
	fmt.Printf("   Cuenta 3: 75 MTC\n")

	// MenÃº interactivo
	scanner := bufio.NewScanner(os.Stdin)

	for {
		fmt.Println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
		fmt.Println("â•‘              MENÃš PRINCIPAL            â•‘")
		fmt.Println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
		fmt.Println("â•‘ 1. Ver cuentas en wallet               â•‘")
		fmt.Println("â•‘ 2. Crear nueva cuenta                  â•‘")
		fmt.Println("â•‘ 3. Ver estado de cuentas               â•‘")
		fmt.Println("â•‘ 4. Crear transacciÃ³n                   â•‘")
		fmt.Println("â•‘ 5. Ver transacciones pendientes        â•‘")
		fmt.Println("â•‘ 6. Minar bloque                        â•‘")
		fmt.Println("â•‘ 7. Ver blockchain completa             â•‘")
		fmt.Println("â•‘ 8. Verificar integridad                â•‘")
		fmt.Println("â•‘ 9. Salir                               â•‘")
		fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		fmt.Print("\nğŸ‘‰ Selecciona una opciÃ³n: ")

		scanner.Scan()
		option := strings.TrimSpace(scanner.Text())

		switch option {
		case "1":
			// Ver cuentas en wallet
			wallet.ListAccounts()

		case "2":
			// Crear nueva cuenta
			address, _ := wallet.CreateAccount()
			fmt.Printf("\nâœ¨ Cuenta creada: %s\n", address)
			fmt.Print("ğŸ’° Â¿Asignar saldo inicial? (cantidad o Enter para 0): ")
			scanner.Scan()
			amountStr := strings.TrimSpace(scanner.Text())
			if amountStr != "" {
				amount, err := strconv.ParseFloat(amountStr, 64)
				if err == nil && amount > 0 {
					bc.AccountState.AddBalance(address, amount)
					fmt.Printf("âœ… Saldo asignado: %.2f MTC\n", amount)
				}
			}

		case "3":
			// Ver estado de cuentas
			bc.AccountState.Print()

		case "4":
			// Crear transacciÃ³n
			fmt.Println("\nğŸ’¸ CREAR TRANSACCIÃ“N")

			// Listar cuentas
			fmt.Println("\nCuentas disponibles:")
			accounts := []string{}
			i := 1
			for address := range wallet.KeyPairs {
				fmt.Printf("%d. %s (Balance: %.2f MTC, Nonce: %d)\n",
					i, address[:16]+"...",
					bc.GetBalance(address),
					bc.GetNonce(address))
				accounts = append(accounts, address)
				i++
			}

			// Seleccionar remitente
			fmt.Print("\nğŸ‘¤ NÃºmero de cuenta remitente: ")
			scanner.Scan()
			fromIdx, err := strconv.Atoi(strings.TrimSpace(scanner.Text()))
			if err != nil || fromIdx < 1 || fromIdx > len(accounts) {
				fmt.Println("âŒ Cuenta invÃ¡lida")
				continue
			}
			fromAddress := accounts[fromIdx-1]

			// Seleccionar destinatario
			fmt.Print("ğŸ‘¤ NÃºmero de cuenta destinatario: ")
			scanner.Scan()
			toIdx, err := strconv.Atoi(strings.TrimSpace(scanner.Text()))
			if err != nil || toIdx < 1 || toIdx > len(accounts) {
				fmt.Println("âŒ Cuenta invÃ¡lida")
				continue
			}
			toAddress := accounts[toIdx-1]

			if fromAddress == toAddress {
				fmt.Println("âŒ No puedes enviar a ti mismo")
				continue
			}

			// Cantidad
			fmt.Print("ğŸ’° Cantidad a enviar: ")
			scanner.Scan()
			amount, err := strconv.ParseFloat(strings.TrimSpace(scanner.Text()), 64)
			if err != nil || amount <= 0 {
				fmt.Println("âŒ Cantidad invÃ¡lida")
				continue
			}

			// Obtener nonce actual
			nonce := bc.GetNonce(fromAddress)

			// Crear transacciÃ³n
			tx := blockchain.NewTransaction(fromAddress, toAddress, amount, nonce)

			// Firmar transacciÃ³n
			keyPair, err := wallet.GetKeyPair(fromAddress)
			if err != nil {
				fmt.Printf("âŒ Error: %v\n", err)
				continue
			}

			if err := tx.Sign(keyPair); err != nil {
				fmt.Printf("âŒ Error firmando: %v\n", err)
				continue
			}

			// Mostrar transacciÃ³n
			tx.Print()

			// AÃ±adir al mempool
			if err := bc.AddTransaction(tx); err != nil {
				fmt.Printf("âŒ Error: %v\n", err)
				continue
			}

		case "5":
			// Ver transacciones pendientes
			bc.PrintPendingTransactions()

		case "6":
			// Minar bloque
			fmt.Println("\nâ›ï¸  MINAR BLOQUE")

			if len(bc.PendingTxs) == 0 {
				fmt.Println("âŒ No hay transacciones pendientes para minar")
				continue
			}

			fmt.Printf("ğŸ“Š Transacciones a incluir: %d\n", len(bc.PendingTxs))
			fmt.Print("âš ï¸  Esto puede tardar unos segundos. Â¿Continuar? (s/n): ")
			scanner.Scan()
			if strings.ToLower(strings.TrimSpace(scanner.Text())) != "s" {
				continue
			}

			if err := bc.MineBlock(); err != nil {
				fmt.Printf("âŒ Error: %v\n", err)
			}

		case "7":
			// Ver blockchain
			bc.Print()

		case "8":
			// Verificar integridad
			fmt.Println("\nğŸ” Verificando integridad de la blockchain...")
			if bc.IsValid() {
				fmt.Println("âœ… Â¡Blockchain vÃ¡lida! Todos los bloques estÃ¡n intactos.")
			} else {
				fmt.Println("âŒ Â¡Blockchain corrupta! Se detectaron alteraciones.")
			}

		case "9":
			// Salir
			fmt.Println("\nğŸ‘‹ Â¡Gracias por usar MiniChain!")
			return

		default:
			fmt.Println("\nâŒ OpciÃ³n invÃ¡lida")
		}
	}
}
*/